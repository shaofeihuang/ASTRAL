import os
import json
import streamlit as st
from dotenv import load_dotenv
from mistralai import Mistral

load_dotenv()

model_token_limits = {
    "pixtral-12b-latest": {"default": 64000, "max": 128000},
    "ministral-8b-latest": {"default": 64000, "max": 128000},
    "mistral-medium-latest": {"default": 64000, "max": 128000},
    "mistral-large-latest": {"default": 64000, "max": 128000},
    "mistral-small-latest": {"default": 24000, "max": 32000},
    "magistral-small-latest": {"default": 32000, "max": 40000},
    "magistral-medium-latest": {"default": 32000, "max": 40000},
}


def get_api_key():
    default_key = os.getenv("MISTRAL_API_KEY", "")
    return st.sidebar.text_input("Mistral API Key", value=default_key, type="password")


def get_model_choice():
    return st.sidebar.selectbox(
        "Select the model you would like to use:",
        list(model_token_limits.keys()),
        key="selected_model",
        help=(
            "Magistral models are Mistral's latest flagship models. "
            "Mistral Large offers premium capabilities, Medium provides balanced performance, "
            "Small is cost-effective, and Ministral 8B is optimized for efficiency."
        ),
    )


def get_system_context():
    return st.sidebar.text_input(
        "Cyber-physical System Context",
        value="Cyber-Physical System",
        placeholder="e.g. Solar PV inverter, ICS, etc.",
        help="Describe the specific cyber-physical system context for tailored threat modelling."
    )


def call_mistral(api_key, prompt_text: str, image_bytes: bytes, model_name: str, max_tokens: int) -> str:
    client = Mistral(api_key=api_key)
    response = client.chat.complete(
        model=model_name,
        response_format={"type": "json_object"},
        messages=[
            {"role": "user", "content": prompt_text, "image": image_bytes}
        ],
        max_tokens=max_tokens,
    )
    response_content = json.loads(response.choices[0].message.content)
    return response_content


def clean_json_response(text: str) -> str:
    # Remove markdown code fences like ```
    if text.startswith("```"):
        last_fence = text.rfind("```")
        if last_fence != -1:
            text = text[3:last_fence].strip()
            if text.lower().startswith("json"):
                text = text[4:].strip()
    return text


def json_to_markdown(threat_model, improvement_suggestions):
    markdown_output = "## Threat Model\n\n"
    
    # Start the markdown table with headers
    markdown_output += "| Threat Type | Scenario | Potential Impact |\n"
    markdown_output += "|-------------|----------|------------------|\n"
    
    # Fill the table rows with the threat model data
    for threat in threat_model:
        markdown_output += f"| {threat['Threat Type']} | {threat['Scenario']} | {threat['Potential Impact']} |\n"
    
    markdown_output += "\n\n## Improvement Suggestions\n\n"
    for suggestion in improvement_suggestions:
        markdown_output += f"- {suggestion}\n"
    
    return markdown_output

def arch_json_to_markdown(arch_explanations):
    markdown_output = "## Architectural Explanation\n\n"
    
    # Start the markdown table with headers
    markdown_output += "| Category |\n"
    markdown_output += "|----------|\n"
    
    # Fill the table rows with the threat model data
    for explanation in arch_explanations:
        markdown_output += f"- {explanation}\n"
    
    return markdown_output

def main():
    st.title("DFD-based Threat Modelling with Mistral AI")

    api_key = get_api_key()
    selected_model = get_model_choice()
    max_tokens = model_token_limits[selected_model]["default"]
    system_context = get_system_context()

    if not api_key:
        st.sidebar.warning("Please enter your Mistral API key.")
        st.stop()

    uploaded_file = st.file_uploader(
        "Upload DFD Image", type=["png", "jpg", "jpeg", "bmp", "gif"]
    )

    if uploaded_file is not None:
        image_bytes = uploaded_file.read()
        st.image(image_bytes, caption="Uploaded DFD Image", width="stretch")

        explanation_prompt = f'''
You are a Senior Solution Architect tasked with explaining the following data flow diagram to a Security Architect to support the threat modelling of the system. In order to complete this task you must:
     1. Analyse the diagram, particularly identifying if an "Attacker" (whether internal or external) exists and treat it as the starting point for any attack path.
     2. Explain the system architecture to the Security Architect. Your explanation should cover the key components, trust boundaries, their interactions, and any technologies used.
     3. The specific system context is: {system_context}

Provide a direct explanation of the diagram in a clear, structured JSON formatted format, with key "section", suitable for a professional discussion.

IMPORTANT INSTRUCTIONS:
     - Do not include any words before or after the explanation itself.
     - Do not infer or speculate about information that is not visible in the diagram. Only provide information that can be directly determined from the diagram itself.
'''

        threat_model_prompt = f'''
Act as a cyber security expert with more than 20 years experience of using the STRIDE-LM threat modelling methodology to produce comprehensive threat models for a wide range of applications. Your task is to analyze the provided DFD to produce a list of specific threats for the application.

If the DFD includes an "Attacker" entity, whether internal or external, treat it as the starting point for any attack path and list threats accordingly.

The system context is: {system_context}

For each of the STRIDE-LM categories, list multiple (3 or 4) credible threats if applicable. Each threat scenario should provide a credible scenario in which the threat could occur in the context of the application. Your responses must reflect the details provided.

Your analysis should include threats specific to cyber-physical systems and not be limited to IT-centric threats.

When providing the threat model, use a JSON formatted response with keys "threat_model" and "improvement_suggestions". Under "threat_model", include an array of objects with keys "Threat Type", "Scenario", and "Potential Impact". Under "improvement_suggestions", list specific lacking information or gaps that would help create a more precise threat analysis (e.g., architectural details, authentication flows, data flow descriptions, technical stack, system boundaries, sensitive data handling).

Do NOT start or end with any non-JSON text or commentary.

Do not provide general security recommendations.
'''

        if st.button("Generate Architectural Explanation"):
            with st.spinner("Generating architectural explanation..."):
                try:
                    model_output = call_mistral(
                        api_key, explanation_prompt, image_bytes, selected_model, max_tokens
                    )
                    st.subheader("Architectural Explanation")
                    arch_explanation = model_output.get("section", [])
                    print (arch_explanation)
                    st.session_state['arch_explanation'] = arch_explanation
                    markdown_output = arch_json_to_markdown(arch_explanation)
                    st.markdown(markdown_output)
                    st.download_button(
                        label="Download Architectural Explanation",
                        data=markdown_output,
                        file_name="arch_explanation.md",
                        mime="text/markdown",
                    )
                except Exception as e:
                    st.error(f"Failed to generate architectural explanation: {str(e)}")

        if st.button("Generate STRIDE-LM Threat Model"):
            with st.spinner("Generating STRIDE-LM threat model..."):
                try:
                    model_output = call_mistral(
                        api_key, threat_model_prompt, image_bytes, selected_model, max_tokens
                    )
                    st.subheader("Generated STRIDE-LM Threat Model")
                    threat_model = model_output.get("threat_model", [])
                    improvement_suggestions = model_output.get("improvement_suggestions", [])
                    st.session_state['threat_model'] = threat_model
                    markdown_output = json_to_markdown(threat_model, improvement_suggestions)
                    st.markdown(markdown_output)
                    st.download_button(
                        label="Download Threat Model",
                        data=markdown_output,
                        file_name="threat_model.md",
                        mime="text/markdown",
                    )

                except Exception as e:
                    st.error(f"Failed to generate threat model: {str(e)}")


if __name__ == "__main__":
    main()
